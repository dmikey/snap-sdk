package main

import (
	"fmt"
	"strings"
)

type PythonGenerator struct{}

func (PythonGenerator) Name() string { return "py" }
func (p PythonGenerator) Generate(stubby Stubby) (string, error) {
	var output strings.Builder

	fmt.Fprintf(&output, "# Generated by Stubby version: %s\n", stubby.Stubby)

	// Generate code for each object and its methods.
	for objName, obj := range stubby.Objects {
		// Write the object.
		fmt.Fprintf(&output, "class %s:\n", objName)

		// Write the __init__ method.
		fmt.Fprintf(&output, "\tdef __init__(self):\n")
		fmt.Fprintf(&output, "\t\tpass\n")

		// Write each method.
		for name, method := range obj.Methods {
			// Create a list of parameter names.
			params := make([]string, len(method.Parameters))
			for i, param := range method.Parameters {
				params[i] = param.Name
			}

			// Write the method signature and docstring.
			fmt.Fprintf(&output, "\n\tdef %s(self, %s):\n", name, strings.Join(params, ", "))
			fmt.Fprintf(&output, "\t\t\"\"\"\n")
			fmt.Fprintf(&output, "\t\t%s\n", method.Description)
			fmt.Fprintf(&output, "\t\t\"\"\"\n")

			// Generate a receiver call if receiver exists
			if receiver, ok := method.Receiver["python"]; ok {
				fmt.Fprintf(&output, "\t\treturn self.%s(%s)\n", receiver, strings.Join(params, ", "))
			} else {
				// Generate a sample return value based on `method.ReturnType`.
				// For now, just return a placeholder object.
				fmt.Fprintf(&output, "\t\treturn %s\n", "{}")
			}
		}
	}

	return output.String(), nil
}
