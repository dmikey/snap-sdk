package main

import (
	"fmt"
	"strings"
)

type RustGenerator struct{}

func (RustGenerator) Name() string { return "rs" }
func (r RustGenerator) Generate(stubby Stubby) (string, error) {
	var output strings.Builder

	fmt.Fprintf(&output, "// Generated by Stubby version: %s\n\n", stubby.Stubby)
	fmt.Fprintf(&output, "#[allow(dead_code)]\n")
	fmt.Fprintf(&output, "pub mod %s {\n", strings.ToLower(stubby.Namespace))

	// Generate struct definitions.
	for name, def := range stubby.Defs {
		fmt.Fprintf(&output, "\t#[derive(Debug)]\n")
		fmt.Fprintf(&output, "\tpub struct %s {\n", name)
		for propName, prop := range def.Properties {
			fmt.Fprintf(&output, "\t\tpub %s: %s,\n", strings.ToLower(propName), r.mapType(prop.Type))
		}
		fmt.Fprintf(&output, "\t}\n\n")
	}

	// Generate code for each object and its methods.
	for _, obj := range stubby.Objects {
		for name, method := range obj.Methods {
			// Create a list of parameter names and types.
			params := []string{}
			for _, param := range method.Parameters {
				paramType := r.mapType(param.Type)
				// If the type is a reference to a definition, get the actual name.
				if param.Ref != "" {
					refName := strings.Split(param.Ref, "/")[2] // Assuming '$ref' is like '#/definitions/User'
					paramType = refName
				}
				params = append(params, fmt.Sprintf("%s: %s", param.Name, paramType))
			}

			// Write the method signature and doc comment.
			fmt.Fprintf(&output, "\t/// %s\n", method.Description)
			if method.ReturnType != nil && method.ReturnType.Ref != "" {
				refName := strings.Split(method.ReturnType.Ref, "/")[2] // Assuming '$ref' is like '#/definitions/User'
				fmt.Fprintf(&output, "\tpub fn %s(&self, %s) -> Result<%s, Error> {\n", strings.ToLower(name), strings.Join(params, ", "), refName)
			} else {
				fmt.Fprintf(&output, "\tpub fn %s(&self, %s) {\n", strings.ToLower(name), strings.Join(params, ", "))
			}

			// Generate a receiver call if receiver exists
			if receiver, ok := method.Receiver["rust"]; ok {
				fmt.Fprintf(&output, "\t\tself.%s(%s)\n", receiver, strings.Join(params, ", "))
			} else {
				// For now, just return.
				fmt.Fprintf(&output, "\t\t// return ...\n")
			}

			fmt.Fprintf(&output, "\t}\n\n")
		}
	}

	fmt.Fprintf(&output, "}\n")

	return output.String(), nil
}

// mapType maps a STUBBY type to a Rust type.
func (r RustGenerator) mapType(stubbyType string) string {
	switch stubbyType {
	case "string":
		return "String"
	case "integer":
		return "i32"
	case "boolean":
		return "bool"
	case "array":
		return "Vec<T>" // TODO: Replace T with the actual type of the elements.
	default:
		return stubbyType
	}
}
